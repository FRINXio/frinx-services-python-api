import re
import yaml
import inspect
import datetime

from argparse import ArgumentParser
from argparse import Namespace
from string import Template
from typing import Optional
from typing import Any
from typing import Iterable

DEFAULT_OUTPUT_FILE = 'rest_api.py'
TAB = '\t'
ENTER = '\n'
NAN = ''


class CustomTemplate(Template):
    delimiter = '_'


class UniconfigRest:
    uri: str
    method: str
    request: Optional[Any]
    response: Optional[Any]


def _set_globals_for_template_cls() -> None:
    global _request, _response
    _request, _response = None, None


_set_globals_for_template_cls()


class _cls(UniconfigRest):
    uri = '_uri'
    method = '_method'
    request = _request
    response = _response


def parse_swagger_scheme(scheme: dict[str, Any]) -> list[str]:
    uniconfig_rest = CustomTemplate(inspect.getsource(_cls))
    definitions = []

    def _to_pascal(s: str) -> str:
        return NAN.join([x.capitalize() for x in s.split('-')])

    def _get_service_name(endpoint: str) -> str:
        service = endpoint.split('/')[-1]
        match = re.search(r'\{(.*?)\}', service)
        if match:
            param = match.groups()[0].capitalize()
            service = service.split('=')[0]
            return _to_pascal(service) + _to_pascal(param)
        return _to_pascal(service)

    def get_inputs(endpoint: str, spec: dict[str, Any]) -> list[dict[str, Any]]:
        i, inputs = {}, []
        methods = list(spec.keys())
        for method in methods:
            if len(methods) > 1:
                i['cls']= _get_service_name(endpoint) + method.capitalize()
            else:
                i['cls']= _get_service_name(endpoint)
            i['uri'] = endpoint
            i['method'] = method.upper()
            # TODO: parse request and response
            i['request'] = None
            i['response'] = None
            inputs.append(i)
        return inputs

    
    for endpoint, spec in scheme['paths'].items():
        try:
            [
                definitions.append(uniconfig_rest.substitute(**i))
                for i in get_inputs(endpoint, spec)
            ]
        except Exception as e:
            print(e)
            ... # TODO: error handling
    return definitions


def generate_file(path: str | None, 
imports: Iterable[str], definitions: Iterable[str]) -> None:

    __filename = __file__.split("/")[-1]
    __date = datetime.datetime.now().strftime('%m/%d/%Y')
    __time = datetime.datetime.now().strftime('%H:%M:%S')
    file = f'# This file was generated by {__filename} on {__date}, in {__time}.'
    file += ENTER + ENTER.join(imports)
    file += 3 * ENTER + (2 *ENTER).join(definitions)
    path = DEFAULT_OUTPUT_FILE if not path else path

    try:
        with open(path, 'w+') as f:
            f.write(file)
        print(f'File {path} was succesfuly generated.')
    except Exception as e:
        print(f'Something went wrong while generating output file {path}', e, sep='\n')


def get_cli_args() -> Namespace:
    parser = ArgumentParser()
    parser.description = 'Python code-gen for Uniconfig Rest.'
    parser.add_argument(
        '--swagger-scheme', 
        type=str, 
        help='Path to OpenAPI-3 scheme in yaml format.', 
        required=True
    )
    parser.add_argument(
        '--output-file', 
        type=str, 
        help=f'(Optional), path for output file. Default is {DEFAULT_OUTPUT_FILE}',
        required=False
    )
    return parser.parse_args()


def main() -> None:
    cli_args = get_cli_args()

    with open(cli_args.swagger_scheme) as f:
        scheme = yaml.safe_load(f)

    imports = ('from typing import Optional', 'from typing import Any')
    definitions = [inspect.getsource(UniconfigRest)]
    definitions += parse_swagger_scheme(scheme)

    generate_file(cli_args.output_file, imports, definitions)

    
main()
