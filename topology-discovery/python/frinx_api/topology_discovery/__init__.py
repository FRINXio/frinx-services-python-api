# generated by datamodel-codegen:
#   filename:  <stdin>
#   timestamp: 2024-11-29T13:24:32+00:00

from __future__ import annotations

from enum import Enum
from typing import List, Literal, Optional, TypeAlias

from pydantic import BaseModel, Field

Boolean: TypeAlias = bool
"""
The `Boolean` scalar type represents `true` or `false`.
"""


Float: TypeAlias = float
"""
The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point).
"""


ID: TypeAlias = str
"""
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
"""


Int: TypeAlias = int
"""
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.
"""


JSON: TypeAlias = str
"""
JSON document.
"""


String: TypeAlias = str
"""
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
"""


class BgpLsProtocolType(Enum):
    """
    BGP-LS Protocol types.
    """

    ISIS = 'ISIS'
    OSPF = 'OSPF'


class CoordinatesNodeType(Enum):
    """
    Type of the node in the topology for which the coordinates are being updated.
    """

    DEVICE = 'DEVICE'
    NETWORK = 'NETWORK'


class GeometryType(Enum):
    """
    Type of geometry.
    """

    POINT = 'POINT'


class MplsOperation(Enum):
    NOOP = 'NOOP'
    POP = 'POP'
    PUSH = 'PUSH'
    SWAP = 'SWAP'


class NetRoutingPathOutputCollections(Enum):
    """
    Types of the nodes that should be included in the returned path.
    """

    NET_DEVICE = 'NET_DEVICE'
    NET_INTERFACE = 'NET_INTERFACE'


class NodeStatus(Enum):
    """
    Status of the node from the view of the device registry.
    """

    OK = 'OK'
    UNKNOWN = 'UNKNOWN'


class PtpPathOutputCollections(Enum):
    """
    Types of the nodes that should be included in the returned path.
    """

    PTP_DEVICE = 'PTP_DEVICE'
    PTP_INTERFACE = 'PTP_INTERFACE'


class Signalisation(Enum):
    LDP = 'LDP'
    RSVP = 'RSVP'


class SyncePathOutputCollections(Enum):
    """
    Types of the nodes that should be included in the returned path.
    """

    SYNCE_DEVICE = 'SYNCE_DEVICE'
    SYNCE_INTERFACE = 'SYNCE_INTERFACE'


class TopologyType(Enum):
    """
    Present topology types.
    """

    ETH_TOPOLOGY = 'ETH_TOPOLOGY'
    MPLS_TOPOLOGY = 'MPLS_TOPOLOGY'
    NETWORK_TOPOLOGY = 'NETWORK_TOPOLOGY'
    PHYSICAL_TOPOLOGY = 'PHYSICAL_TOPOLOGY'
    PTP_TOPOLOGY = 'PTP_TOPOLOGY'


class Node(BaseModel):
    """
    Generic node that can be identified using Globally Unique ID.
    """

    id: ID = Field(..., description='Unique identifier of the object.')
    typename__: Optional[Literal['Node']] = Field('Node', alias='__typename')


class CommonNodesResponse(BaseModel):
    """
    Response from the commonNodes query that wraps the list of found common nodes in the database.
    """

    commonNodes: List[String] = Field(
        ...,
        description='List of the common node names. Common nodes contain connection to all nodes specified on the input.',
    )
    typename__: Optional[Literal['CommonNodesResponse']] = Field(
        'CommonNodesResponse', alias='__typename'
    )


class Coordinates(BaseModel):
    """
    Coordinates of the node on the graph.
    """

    x: Float = Field(..., description='Horizontal coordinate of the node on the graph.')
    y: Float = Field(..., description='Vertical coordinate of the node on the graph.')
    typename__: Optional[Literal['Coordinates']] = Field(
        'Coordinates', alias='__typename'
    )


class CoordinatesResponse(BaseModel):
    """
    Response from the updateCoordinates query that contains information about updated coordinated of selected nodes.
    """

    installed: InstalledDevices = Field(
        ..., description='Devices that exist in the database.'
    )
    notInstalled: List[String] = Field(
        ..., description='List of node names that do not exist in the database.'
    )
    typename__: Optional[Literal['CoordinatesResponse']] = Field(
        'CoordinatesResponse', alias='__typename'
    )


class CreateBackupResponse(BaseModel):
    """
    Response from the createBackup mutation that contains information about created backup.
    """

    dbName: String = Field(
        ...,
        description='Name of the created backup database. Format: f"backup_{datetime.today().strftime(\'%Y%m%d%H%M%S\')}".',
    )
    typename__: Optional[Literal['CreateBackupResponse']] = Field(
        'CreateBackupResponse', alias='__typename'
    )


class DeleteBackupsResponse(BaseModel):
    """
    Response from the deleteBackups mutation that contains information about removed backups.
    """

    deletedBackups: List[String] = Field(
        ..., description='Names of the removed databases that contained backups.'
    )
    typename__: Optional[Literal['DeleteBackupsResponse']] = Field(
        'DeleteBackupsResponse', alias='__typename'
    )


class DeviceGeoLocation(BaseModel):
    """
    Device GeoLocation data.
    """

    bbox: Optional[List[Optional[Float]]] = Field(
        None,
        description='Defining the area around the device, with four elements indicating its boundaries.',
    )
    coordinates: List[Float] = Field(
        ...,
        description='Device location coordinates providing longitude and latitude (in this order, based on GeoJSON convention).',
    )
    type: GeometryType = Field(..., description='Type of geometry.')
    typename__: Optional[Literal['DeviceGeoLocation']] = Field(
        'DeviceGeoLocation', alias='__typename'
    )


class DeviceMetadata(Node):
    """
    Representation of the device in the metadata.
    """

    deviceName: String = Field(..., description='Human readable name of the device.')
    deviceType: Optional[String] = Field(
        None, description='Type of the device (ex. router).'
    )
    geoLocation: Optional[DeviceGeoLocation] = Field(
        None, description='Device geographic data of point type in GeoJson format.'
    )
    id: ID = Field(..., description='Unique identifier of the object.')
    model: Optional[String] = Field(None, description='Model of the device (XR, ASR).')
    protocolType: Optional[List[String]] = Field(
        None,
        description='Protocol used for management for the device (cli, netconf, gnmi).',
    )
    vendor: Optional[String] = Field(
        None, description='Vendor of the device (ex. Cisco).'
    )
    version: Optional[String] = Field(
        None, description='Version of the device software (ex. 6.0.1).'
    )
    typename__: Optional[Literal['DeviceMetadata']] = Field(
        'DeviceMetadata', alias='__typename'
    ) # type: ignore


class DeviceMetadataEdge(BaseModel):
    """
    Grouped Metadata device object and associated cursor used by pagination.
    """

    cursor: String = Field(..., description='Pagination cursor for this edge.')
    node: Optional[DeviceMetadata] = Field(
        None, description='The associated MetadataDevice object.'
    )
    typename__: Optional[Literal['DeviceMetadataEdge']] = Field(
        'DeviceMetadataEdge', alias='__typename'
    )


class InstalledDevices(BaseModel):
    notUpdated: List[String] = Field(
        ..., description='List of node names which coordinates have not been updated.'
    )
    updated: List[String] = Field(
        ..., description='List of node names which coordinates have been updated.'
    )
    typename__: Optional[Literal['InstalledDevices']] = Field(
        'InstalledDevices', alias='__typename'
    )


class LspTunnel(BaseModel):
    """
    LSP Tunnel (related to tunnel originating from this device).
    """

    fromDevice: Optional[String] = Field(
        None, description='From which device is the tunnel originating.'
    )
    lspId: String = Field(..., description='Name of the link state packet.')
    signalisation: Signalisation = Field(..., description='Type of signalisation.')
    toDevice: Optional[String] = Field(None, description='Where is the tunnel headed.')
    uptime: Optional[Int] = Field(None, description='Uptime of the tunnel in seconds.')
    typename__: Optional[Literal['LspTunnel']] = Field('LspTunnel', alias='__typename')


class MetadataConnection(BaseModel):
    """
    Grouped list of Metadata device objects and pagination metadata.
    """

    edges: Optional[List[Optional[DeviceMetadataEdge]]] = Field(
        None, description='List of Metadata device objects.'
    )
    pageInfo: PageInfo = Field(..., description='Pagination metadata.')
    typename__: Optional[Literal['MetadataConnection']] = Field(
        'MetadataConnection', alias='__typename'
    )


class MplsData(BaseModel):
    """
    MPLS Data (related to all tunnels).
    """

    inInterface: Optional[String] = Field(None, description='The input interface.')
    inLabel: Optional[Int] = Field(None, description='The input label.')
    lspId: String = Field(..., description='Name of the link state packet.')
    mplsOperation: Optional[MplsOperation] = Field(
        None, description='The operation type.'
    )
    operState: Optional[String] = Field(
        None, description='Operational state of the device.'
    )
    outInterface: Optional[String] = Field(None, description='The input interface.')
    outLabel: Optional[Int] = Field(None, description='The output label.')
    signalisation: Optional[Signalisation] = Field(
        None, description='Type of signalisation.'
    )
    typename__: Optional[Literal['MplsData']] = Field('MplsData', alias='__typename')


class MplsDevice(Node):
    """
    Representation of the device in the MPLS topology.
    """

    coordinates: Coordinates = Field(
        ..., description='Coordinates of the device node on the graph.'
    )
    details: MplsDeviceDetails = Field(..., description='Details of the device.')
    id: ID = Field(..., description='Unique identifier of the object.')
    labels: Optional[List[String]] = Field(
        None,
        description='List of strings that can be used for grouping of synced devices.',
    )
    mplsInterfaces: MplsInterfaceConnection = Field(
        ..., description='List of ports that are present on the device.'
    )
    name: String = Field(..., description='Human readable name of the device.')
    status: NodeStatus = Field(
        ..., description='Status of the device from the view of the synced topology.'
    )
    typename__: Optional[Literal['MplsDevice']] = Field(
        'MplsDevice', alias='__typename'
    ) # type: ignore


class MplsDeviceConnection(BaseModel):
    """
    Grouped list of MplsDevice objects and pagination metadata.
    """

    edges: Optional[List[Optional[MplsDeviceEdge]]] = Field(
        None, description='List of MplsDevice objects.'
    )
    pageInfo: PageInfo = Field(..., description='Pagination metadata.')
    typename__: Optional[Literal['MplsDeviceConnection']] = Field(
        'MplsDeviceConnection', alias='__typename'
    )


class MplsDeviceDetails(BaseModel):
    """
    Details specific to MPLS (Multi-Protocol Label Switching).
    """

    lspTunnels: Optional[List[Optional[LspTunnel]]] = None
    mplsData: Optional[List[Optional[MplsData]]] = None
    routerId: Optional[String] = None
    typename__: Optional[Literal['MplsDeviceDetails']] = Field(
        'MplsDeviceDetails', alias='__typename'
    )


class MplsDeviceEdge(BaseModel):
    """
    Grouped MplsDevice object and associated cursor used by pagination.
    """

    cursor: String = Field(..., description='Pagination cursor for this edge.')
    node: Optional[MplsDevice] = Field(
        None, description='The associated MplsDevice object.'
    )
    typename__: Optional[Literal['MplsDeviceEdge']] = Field(
        'MplsDeviceEdge', alias='__typename'
    )


class MplsInterface(Node):
    """
    Port attached to the MPLS device.
    """

    id: ID = Field(..., description='Unique identifier of the object.')
    mplsDevice: Optional[MplsDevice] = Field(
        None, description='Device that owns this interface.'
    )
    mplsLinks: Optional[MplsLinkConnection] = Field(
        None, description='Link to connected remote MPLS device.'
    )
    name: String = Field(..., description='Human readable name of the network port.')
    status: NodeStatus = Field(
        ...,
        description="Status of the interface from the view of the synced topology ('ok' or 'unknown').",
    )
    typename__: Optional[Literal['MplsInterface']] = Field(
        'MplsInterface', alias='__typename'
    ) # type: ignore


class MplsInterfaceConnection(BaseModel):
    """
    Grouped list of MplsInterface objects and pagination metadata.
    """

    edges: Optional[List[Optional[MplsInterfaceEdge]]] = Field(
        None, description='List of MplsInterface objects.'
    )
    pageInfo: PageInfo = Field(..., description='Pagination metadata.')
    typename__: Optional[Literal['MplsInterfaceConnection']] = Field(
        'MplsInterfaceConnection', alias='__typename'
    )


class MplsInterfaceEdge(BaseModel):
    """
    Grouped MplsInterface object and associated cursor used by pagination.
    """

    cursor: String = Field(..., description='Pagination cursor for this edge.')
    node: Optional[MplsInterface] = Field(
        None, description='The associated MplsInterface object.'
    )
    typename__: Optional[Literal['MplsInterfaceEdge']] = Field(
        'MplsInterfaceEdge', alias='__typename'
    )


class MplsLinkConnection(BaseModel):
    """
    Grouped list of MplsLinks objects and pagination metadata.
    """

    edges: Optional[List[Optional[MplsLinkEdge]]] = Field(
        None, description='List of MplsInterface objects.'
    )
    pageInfo: PageInfo = Field(..., description='Pagination metadata.')
    typename__: Optional[Literal['MplsLinkConnection']] = Field(
        'MplsLinkConnection', alias='__typename'
    )


class MplsLinkEdge(BaseModel):
    """
    Grouped MplsLink object and associated cursor used by pagination.
    """

    cursor: String = Field(..., description='Pagination cursor for this edge.')
    link: Optional[ID] = Field(
        None,
        description='Identifier of the link that connects this interface to the interface on the remote device',
    )
    node: Optional[MplsInterface] = Field(
        None, description='The associated MplsInterface object.'
    )
    typename__: Optional[Literal['MplsLinkEdge']] = Field(
        'MplsLinkEdge', alias='__typename'
    )


class MplsLspMetadata(BaseModel):
    fromDevice: String = Field(
        ..., description='From which device is the tunnel originating.'
    )
    signalisation: String = Field(..., description='Type of signalisation.')
    toDevice: String = Field(..., description='Where is the tunnel headed.')
    uptime: Optional[Int] = Field(None, description='Uptime of the tunnel in seconds.')
    typename__: Optional[Literal['MplsLspMetadata']] = Field(
        'MplsLspMetadata', alias='__typename'
    )


class MplsLspPath(BaseModel):
    lspMetadata: Optional[MplsLspMetadata] = Field(None, description='LSP metadata.')
    path: Optional[List[Optional[String]]] = Field(
        None, description='Ordered list of link IDs & device IDs on the path.'
    )
    typename__: Optional[Literal['MplsLspPath']] = Field(
        'MplsLspPath', alias='__typename'
    )


class MplsTotalLsps(BaseModel):
    incomingLsps: Optional[Int] = Field(None, description='Number of incoming LSPs.')
    outcomingLsps: Optional[Int] = Field(None, description='Number of outcoming LSPs.')
    toDevice: Optional[String] = Field(
        None, description='To which device the LSP is headed.'
    )
    typename__: Optional[Literal['MplsTotalLsps']] = Field(
        'MplsTotalLsps', alias='__typename'
    )


class Neighbor(BaseModel):
    """
    Metadata information about a neighbor device.
    """

    deviceId: String = Field(
        ...,
        description='Identifier of the neighbor device document (for example, MplsDevice/1).',
    )
    deviceName: String = Field(
        ...,
        description='Human-readable name of the neighbor device (for example, CPE_01).',
    )
    typename__: Optional[Literal['Neighbor']] = Field('Neighbor', alias='__typename')


class NetDevice(Node):
    """
    Representation of the routing entity in the network topology.
    """

    coordinates: Coordinates = Field(
        ..., description='Coordinates of the device node on the graph.'
    )
    id: ID = Field(..., description='Unique identifier of the object.')
    netInterfaces: NetInterfaceConnection = Field(
        ...,
        description='Interfaces that are used for connecting to other routing entities.',
    )
    netNetworks: NetNetworkConnection = Field(
        ..., description='Networks that are attached to the routing entity.'
    )
    ospfAreaId: String = Field(
        ...,
        description='Identifier of OSPF area formatted as IPv4 address (for example, 0.0.0.0 represents area 0).',
    )
    phyDevice: Optional[PhyDevice] = Field(
        None, description='Linked device in the physical topology.'
    )
    routerId: String = Field(
        ...,
        description='Identifier of the routing entity (usually IPv4 address). RouterId and ospfAreaId together compose a unique key.',
    )
    typename__: Optional[Literal['NetDevice']] = Field('NetDevice', alias='__typename') # type: ignore


class NetDeviceConnection(BaseModel):
    """
    Grouped list of NetDevice objects and pagination metadata.
    """

    edges: Optional[List[Optional[NetDeviceEdge]]] = Field(
        None, description='List of NetDevice objects.'
    )
    pageInfo: PageInfo = Field(..., description='Pagination metadata.')
    typename__: Optional[Literal['NetDeviceConnection']] = Field(
        'NetDeviceConnection', alias='__typename'
    )


class NetDeviceEdge(BaseModel):
    """
    Grouped NetDevice object and associated cursor used by pagination.
    """

    cursor: String = Field(..., description='Pagination cursor for this edge.')
    node: Optional[NetDevice] = Field(
        None, description='The associated NetDevice object.'
    )
    typename__: Optional[Literal['NetDeviceEdge']] = Field(
        'NetDeviceEdge', alias='__typename'
    )


class NetInterface(Node):
    """
    Network interface attached to the network device.
    """

    id: ID = Field(..., description='Unique identifier of the object.')
    igpMetric: Optional[Int] = Field(
        None, description='IGP metric configured on the network interface.'
    )
    ipAddress: String = Field(
        ..., description='IP address configured on the interface.'
    )
    netDevice: Optional[NetDevice] = Field(
        None, description='Routing entity that owns this interface.'
    )
    netLinks: NetLinkConnection = Field(
        ..., description='Links to connected remote network devices.'
    )
    typename__: Optional[Literal['NetInterface']] = Field(
        'NetInterface', alias='__typename'
    ) # type: ignore


class NetInterfaceConnection(BaseModel):
    """
    Grouped list of NetInterface objects and pagination metadata.
    """

    edges: Optional[List[Optional[NetInterfaceEdge]]] = Field(
        None, description='List of NetInterface objects.'
    )
    pageInfo: PageInfo = Field(..., description='Pagination metadata.')
    typename__: Optional[Literal['NetInterfaceConnection']] = Field(
        'NetInterfaceConnection', alias='__typename'
    )


class NetInterfaceEdge(BaseModel):
    """
    Grouped NetInterface object and associated cursor used by pagination.
    """

    cursor: String = Field(..., description='Pagination cursor for this edge.')
    node: Optional[NetInterface] = Field(
        None, description='The associated NetInterface object.'
    )
    typename__: Optional[Literal['NetInterfaceEdge']] = Field(
        'NetInterfaceEdge', alias='__typename'
    )


class NetLinkAttributes(BaseModel):
    adminGroup: Optional[List[Optional[Int]]] = Field(
        None,
        description='A list of admin group masks on the network interface. (Group Number)',
    )
    igpMetric: Optional[Int] = Field(
        None, description='IGP metric configured on the network interface.'
    )
    maxLinkBandwidth: Optional[Float] = Field(
        None,
        description='The maximum link bandwidth of the network interface. (Bytes per second)',
    )
    maxReservableLinkBandwidth: Optional[Float] = Field(
        None,
        description='The maximum reservable link bandwidth of the network interface. (Bytes per second)',
    )
    sharedRiskLinkGroup: Optional[List[Optional[Int]]] = Field(
        None, description='A list of shared risk link groups on the network interface.'
    )
    trafficEngineeringMetric: Optional[Int] = Field(
        None, description='Traffic Engineering metric on the network interface.'
    )
    unreservedBandwidth: Optional[List[Optional[Float]]] = Field(
        None,
        description='The unreserved bandwidth on the network interface. (Bytes per second)',
    )
    typename__: Optional[Literal['NetLinkAttributes']] = Field(
        'NetLinkAttributes', alias='__typename'
    )


class NetLinkConnection(BaseModel):
    """
    Grouped list of NetLinks objects and pagination metadata.
    """

    edges: Optional[List[Optional[NetLinkEdge]]] = Field(
        None, description='List of NetInterface objects.'
    )
    pageInfo: PageInfo = Field(..., description='Pagination metadata.')
    typename__: Optional[Literal['NetLinkConnection']] = Field(
        'NetLinkConnection', alias='__typename'
    )


class NetLinkEdge(BaseModel):
    attributes: Optional[NetLinkAttributes] = Field(
        None, description='List of attributes associated to the link.'
    )
    cursor: String = Field(..., description='Pagination cursor for this edge.')
    link: Optional[ID] = Field(
        None,
        description='Identifier of the link that connects this interface to the interface on the remote device',
    )
    node: Optional[NetInterface] = Field(
        None, description='The associated NetInterface object.'
    )
    typename__: Optional[Literal['NetLinkEdge']] = Field(
        'NetLinkEdge', alias='__typename'
    )


class NetNetwork(Node):
    """
    IP subnet in the network topology.
    """

    coordinates: Coordinates = Field(
        ..., description='Coordinates of the network node on the graph.'
    )
    id: ID = Field(..., description='Unique identifier of the object.')
    ospfRouteType: Int = Field(..., description='Type of the OSPF network (LSA type).')
    subnet: String = Field(
        ...,
        description='Network address including prefix length expressed in the CIDR notation (e.g. 10.0.0.0/24).',
    )
    typename__: Optional[Literal['NetNetwork']] = Field(
        'NetNetwork', alias='__typename'
    ) # type: ignore


class NetNetworkConnection(BaseModel):
    """
    Grouped list of NetNetwork objects and pagination metadata.
    """

    edges: Optional[List[Optional[NetNetworkEdge]]] = Field(
        None, description='List of NetNetwork objects.'
    )
    pageInfo: Optional[PageInfo] = Field(None, description='Pagination metadata.')
    typename__: Optional[Literal['NetNetworkConnection']] = Field(
        'NetNetworkConnection', alias='__typename'
    )


class NetNetworkEdge(BaseModel):
    cursor: String = Field(..., description='Pagination cursor for this edge.')
    node: Optional[NetNetwork] = Field(
        None, description='The associated NetNetwork object.'
    )
    typename__: Optional[Literal['NetNetworkEdge']] = Field(
        'NetNetworkEdge', alias='__typename'
    )


class NetRoutingPathConnection(BaseModel):
    """
    Computed routing paths from source to destination device.
    """

    edges: Optional[List[RoutingPath]] = Field(
        None,
        description='List of routing paths from source to destination device. Ordered from shortest to longest path based on weight.',
    )
    typename__: Optional[Literal['NetRoutingPathConnection']] = Field(
        'NetRoutingPathConnection', alias='__typename'
    )


class NodeCoordinates(BaseModel):
    """
    Represents the coordinates of a specific node in the topology.
    """

    nodeId: String = Field(..., description='Name of the node in the topology.')
    x: Float = Field(
        ...,
        description='Refreshed horizontal coordinate of the node on the graph. Value is between 0.0 and 1.0.',
    )
    y: Float = Field(
        ...,
        description='Refreshed vertical coordinate of the node on the graph. Value is between 0.0 and 1.0.',
    )
    typename__: Optional[Literal['NodeCoordinates']] = Field(
        'NodeCoordinates', alias='__typename'
    )


class NodeInfo(BaseModel):
    """
    Information about a node that is part of the computed path.
    """

    node: ID = Field(..., description='Unique identifier of the node on the path.')
    weight: Optional[Int] = Field(
        None,
        description='Weight of the node on the path. Weight is present only on the nodes of NetDevice type.',
    )
    typename__: Optional[Literal['NodeInfo']] = Field('NodeInfo', alias='__typename')


class PageInfo(BaseModel):
    """
    Pagination metadata that is usually coupled to a returned list of objects.
    """

    endCursor: Optional[String] = Field(
        None, description='Pointer to the last object in the list.'
    )
    hasNextPage: Boolean = Field(
        ..., description='Indicates if there is a next object in the list.'
    )
    typename__: Optional[Literal['PageInfo']] = Field('PageInfo', alias='__typename')


class PhyDevice(Node):
    """
    Representation of the device in the physical topology.
    """

    coordinates: Coordinates = Field(
        ..., description='Coordinates of the device node on the graph.'
    )
    details: PhyDeviceDetails = Field(..., description='Details of the device.')
    id: ID = Field(..., description='Unique identifier of the object.')
    labels: Optional[List[String]] = Field(
        None,
        description='List of strings that can be used for grouping of synced devices.',
    )
    name: String = Field(..., description='Human readable name of the device.')
    netDevice: Optional[NetDevice] = Field(
        None, description='Linked device in the network topology.'
    )
    phyInterfaces: PhyInterfaceConnection = Field(
        ..., description='List of ports that are present on the device.'
    )
    routerId: Optional[String] = Field(
        None,
        description='Identifier of the corresponding routing entity in the network topology.',
    )
    status: NodeStatus = Field(
        ..., description='Status of the device from the view of the synced topology.'
    )
    typename__: Optional[Literal['PhyDevice']] = Field('PhyDevice', alias='__typename') # type: ignore


class PhyDeviceConnection(BaseModel):
    """
    Grouped list of PhyDevice objects and pagination metadata.
    """

    edges: Optional[List[Optional[PhyDeviceEdge]]] = Field(
        None, description='List of PhyDevice objects.'
    )
    pageInfo: PageInfo = Field(..., description='Pagination metadata.')
    typename__: Optional[Literal['PhyDeviceConnection']] = Field(
        'PhyDeviceConnection', alias='__typename'
    )


class PhyDeviceDetails(BaseModel):
    """
    Details of the device.
    """

    deviceType: Optional[String] = Field(
        None,
        description='Device type (e.g. device model, vendor, chassis, hardware details, etc.)',
    )
    swVersion: Optional[String] = Field(
        None,
        description='Version of the network operating system running on the device.',
    )
    typename__: Optional[Literal['PhyDeviceDetails']] = Field(
        'PhyDeviceDetails', alias='__typename'
    )


class PhyDeviceEdge(BaseModel):
    """
    Grouped PhyDevice object and associated cursor used by pagination.
    """

    cursor: String = Field(..., description='Pagination cursor for this edge.')
    node: Optional[PhyDevice] = Field(
        None, description='The associated PhyDevice object.'
    )
    typename__: Optional[Literal['PhyDeviceEdge']] = Field(
        'PhyDeviceEdge', alias='__typename'
    )


class PhyInterface(Node):
    """
    Port attached to the physical device.
    """

    details: Optional[PhyInterfaceDetails] = Field(
        None, description='Details of the interface.'
    )
    id: ID = Field(..., description='Unique identifier of the object.')
    name: String = Field(..., description='Human readable name of the network port.')
    phyDevice: Optional[PhyDevice] = Field(
        None, description='Device that owns this interface.'
    )
    phyLinks: PhyLinkConnection = Field(
        ..., description='List of links connected to remote physical device.'
    )
    status: NodeStatus = Field(
        ...,
        description="Status of the interface from the view of the synced topology ('ok' or 'unknown').",
    )
    typename__: Optional[Literal['PhyInterface']] = Field(
        'PhyInterface', alias='__typename'
    ) # type: ignore


class PhyInterfaceConnection(BaseModel):
    """
    Grouped list of PhyInterface objects and pagination metadata.
    """

    edges: Optional[List[Optional[PhyInterfaceEdge]]] = Field(
        None, description='List of PhyInterface objects.'
    )
    pageInfo: PageInfo = Field(..., description='Pagination metadata.')
    typename__: Optional[Literal['PhyInterfaceConnection']] = Field(
        'PhyInterfaceConnection', alias='__typename'
    )


class PhyInterfaceDetails(BaseModel):
    """
    Details of the interface.
    """

    maxSpeed: Optional[Float] = Field(
        None, description='Max operational interface bandwidth in Mbit.'
    )
    typename__: Optional[Literal['PhyInterfaceDetails']] = Field(
        'PhyInterfaceDetails', alias='__typename'
    )


class PhyInterfaceEdge(BaseModel):
    """
    Grouped PhyInterface object and associated cursor used by pagination.
    """

    cursor: String = Field(..., description='Pagination cursor for this edge.')
    node: Optional[PhyInterface] = Field(
        None, description='The associated PhyInterface object.'
    )
    typename__: Optional[Literal['PhyInterfaceEdge']] = Field(
        'PhyInterfaceEdge', alias='__typename'
    )


class PhyLinkConnection(BaseModel):
    """
    Grouped list of PhyLinks objects and pagination metadata.
    """

    edges: Optional[List[Optional[PhyLinkEdge]]] = Field(
        None, description='List of PhyInterface objects.'
    )
    pageInfo: PageInfo = Field(..., description='Pagination metadata.')
    typename__: Optional[Literal['PhyLinkConnection']] = Field(
        'PhyLinkConnection', alias='__typename'
    )


class PhyLinkEdge(BaseModel):
    cursor: String = Field(..., description='Pagination cursor for this edge.')
    link: Optional[ID] = Field(
        None,
        description='Identifier of the link that connects this interface to the interface on the remote device',
    )
    node: Optional[PhyInterface] = Field(
        None, description='The associated PhyInterface object.'
    )
    typename__: Optional[Literal['PhyLinkEdge']] = Field(
        'PhyLinkEdge', alias='__typename'
    )


class ProviderResponse(BaseModel):
    """
    Response from the provider query that contains information about supported device types in the specified topology.
    """

    supportedDevices: List[String] = Field(
        ...,
        description='List of the supported device types in the specified topology (e.g. ios, ios xe, sros, etc.)',
    )
    typename__: Optional[Literal['ProviderResponse']] = Field(
        'ProviderResponse', alias='__typename'
    )


class PtpDevice(Node):
    """
    Representation of the device in the ptp topology.
    """

    coordinates: Coordinates = Field(
        ..., description='Coordinates of the device node on the graph.'
    )
    details: PtpDeviceDetails = Field(..., description='Details of the device.')
    id: ID = Field(..., description='Unique identifier of the object.')
    labels: Optional[List[String]] = Field(
        None,
        description='List of strings that can be used for grouping of synced devices.',
    )
    name: String = Field(..., description='Human readable name of the device.')
    ptpInterfaces: PtpInterfaceConnection = Field(
        ..., description='List of ports that are present on the device.'
    )
    status: NodeStatus = Field(
        ..., description='Status of the device from the view of the synced topology.'
    )
    typename__: Optional[Literal['PtpDevice']] = Field('PtpDevice', alias='__typename') # type: ignore


class PtpDeviceConnection(BaseModel):
    """
    Grouped list of PtpDevice objects and pagination metadata.
    """

    edges: Optional[List[Optional[PtpDeviceEdge]]] = Field(
        None, description='List of PtpDevice objects.'
    )
    pageInfo: PageInfo = Field(..., description='Pagination metadata.')
    typename__: Optional[Literal['PtpDeviceConnection']] = Field(
        'PtpDeviceConnection', alias='__typename'
    )


class PtpDeviceDetails(BaseModel):
    """
    Details specific to PTP (Precision Time Protocol).
    """

    clockAccuracy: Optional[String] = Field(
        None,
        description='How accurate is the clock output to primary reference. This parameter is often automatically determined\nby the device based on the characteristics of its internal clock oscillator and how well it can track\nthe reference time.',
    )
    clockClass: Optional[Int] = Field(
        None, description='Measure of clock traceability.'
    )
    clockId: Optional[String] = Field(
        None, description='Unique identifier of the clock.'
    )
    clockType: Optional[String] = Field(
        None, description='Type of clock (e.g., ordinary, master).'
    )
    clockVariance: Optional[String] = Field(
        None,
        description="Measure of clock precision. How much the clock-output varies when not synchronized to another source.\nThe variance is determined by assessing how much the local clock deviates from the ideal time over a certain period,\noften expressed in parts per billion (ppb) or as the standard deviation of the clock's offset.",
    )
    domain: Optional[Int] = Field(None, description='Domain of the PTP network.')
    globalPriority: Optional[Int] = Field(
        None, description='Global priority of the clock (the first priority).'
    )
    gmClockId: Optional[String] = Field(
        None, description='Unique identifier of the grandmaster clock.'
    )
    parentClockId: Optional[String] = Field(
        None, description='Unique identifier of the parent clock.'
    )
    ptpPortState: Optional[String] = Field(
        None, description='The port state of the device.'
    )
    ptpProfile: Optional[String] = Field(
        None, description='PTP profile used (e.g., ITU-T G.8275.1).'
    )
    timeRecoveryStatus: Optional[String] = Field(
        None,
        description='Indicates the current state of the time recovery process. Time recovery is the process of adjusting\nthe local clock to synchronize with a more accurate reference clock.',
    )
    userPriority: Optional[Int] = Field(
        None, description='User defined value of the second priority.'
    )
    typename__: Optional[Literal['PtpDeviceDetails']] = Field(
        'PtpDeviceDetails', alias='__typename'
    )


class PtpDeviceEdge(BaseModel):
    """
    Grouped PtpDevice object and associated cursor used by pagination.
    """

    cursor: String = Field(..., description='Pagination cursor for this edge.')
    node: Optional[PtpDevice] = Field(
        None, description='The associated PtpDevice object.'
    )
    typename__: Optional[Literal['PtpDeviceEdge']] = Field(
        'PtpDeviceEdge', alias='__typename'
    )


class PtpDiffSynce(Node):
    """
    A Ptp node that uses a different upstream path in SyncE topology
    """

    id: ID = Field(..., description='Ptp node id')
    ptpUpstreamInterface: Optional[ID] = Field(
        None, description="Ptp node's upstream interface"
    )
    ptpUpstreamInterfaceName: Optional[String] = Field(
        None, description="Ptp node's upstream interface name"
    )
    ptpUpstreamInterfaceStatus: Optional[String] = Field(
        None, description="Ptp node's upstream interface status"
    )
    synceId: Optional[ID] = Field(
        None, description='SyncE node id. This is the same device as identified'
    )
    synceUpstreamInterfaceName: Optional[String] = Field(
        None, description="Synce node's upstream interface name"
    )
    typename__: Optional[Literal['PtpDiffSynce']] = Field(
        'PtpDiffSynce', alias='__typename'
    ) # type: ignore


class PtpDiffSynceConnection(BaseModel):
    """
    Grouped list of PtpDiffSynceDevice objects and pagination metadata.
    """

    edges: Optional[List[Optional[PtpDiffSynceEdge]]] = Field(
        None, description='List of PtpDiffSynce objects.'
    )
    pageInfo: PageInfo = Field(..., description='Pagination metadata.')
    typename__: Optional[Literal['PtpDiffSynceConnection']] = Field(
        'PtpDiffSynceConnection', alias='__typename'
    )


class PtpDiffSynceEdge(BaseModel):
    """
    Grouped PtpDiffSynceDevice object and associated cursor used by pagination.
    """

    cursor: String = Field(..., description='Pagination cursor for this edge.')
    node: Optional[PtpDiffSynce] = Field(
        None, description='The associated PtpDiffSynce object.'
    )
    typename__: Optional[Literal['PtpDiffSynceEdge']] = Field(
        'PtpDiffSynceEdge', alias='__typename'
    )


class PtpInterface(Node):
    """
    Port attached to the ptp device.
    """

    details: Optional[PtpInterfaceDetails] = Field(
        None, description='Interface details specific to PTP (Precision Time Protocol).'
    )
    id: ID = Field(..., description='Unique identifier of the object.')
    name: String = Field(..., description='Human readable name of the network port.')
    ptpDevice: Optional[PtpDevice] = Field(
        None, description='Device that owns this interface.'
    )
    ptpLinks: PtpLinkConnection = Field(
        ..., description='List of links connected to remote ptp devices.'
    )
    status: NodeStatus = Field(
        ...,
        description="Status of the interface from the view of the synced topology ('ok' or 'unknown').",
    )
    typename__: Optional[Literal['PtpInterface']] = Field(
        'PtpInterface', alias='__typename'
    ) # type: ignore


class PtpInterfaceConnection(BaseModel):
    """
    Grouped list of PtpInterface objects and pagination metadata.
    """

    edges: Optional[List[Optional[PtpInterfaceEdge]]] = Field(
        None, description='List of PtpInterface objects.'
    )
    pageInfo: PageInfo = Field(..., description='Pagination metadata.')
    typename__: Optional[Literal['PtpInterfaceConnection']] = Field(
        'PtpInterfaceConnection', alias='__typename'
    )


class PtpInterfaceDetails(BaseModel):
    """
    PTP interface details.
    """

    adminOperStatus: String = Field(
        ...,
        description="Administrative/operational status of the interface (e.g. 'up/up', 'up/down').",
    )
    ptpStatus: String = Field(
        ...,
        description="State of the PTP process on the interface (e.g. 'master', 'slave', 'disabled', 'passive', 'unknown').",
    )
    ptsfUnusable: String = Field(
        ...,
        description='Unusable packet timing signal received by the slave, for example, where the packet delay variation is excessive,\nresulting in the slave being unable to meet the output clock performance requirements.',
    )
    typename__: Optional[Literal['PtpInterfaceDetails']] = Field(
        'PtpInterfaceDetails', alias='__typename'
    )


class PtpInterfaceEdge(BaseModel):
    """
    Grouped PtpInterface object and associated cursor used by pagination.
    """

    cursor: String = Field(..., description='Pagination cursor for this edge.')
    node: Optional[PtpInterface] = Field(
        None, description='The associated PtpInterface object.'
    )
    typename__: Optional[Literal['PtpInterfaceEdge']] = Field(
        'PtpInterfaceEdge', alias='__typename'
    )


class PtpLinkConnection(BaseModel):
    """
    Grouped list of PtpLinks objects and pagination metadata.
    """

    edges: Optional[List[Optional[PtpLinkEdge]]] = Field(
        None, description='List of PtpInterface objects.'
    )
    pageInfo: PageInfo = Field(..., description='Pagination metadata.')
    typename__: Optional[Literal['PtpLinkConnection']] = Field(
        'PtpLinkConnection', alias='__typename'
    )


class PtpLinkEdge(BaseModel):
    """
    Grouped PtpLink object and associated cursor used by pagination.
    """

    cursor: String = Field(..., description='Pagination cursor for this edge.')
    link: Optional[ID] = Field(
        None,
        description='Identifier of the link that connects this interface to the interface on the remote device',
    )
    node: Optional[PtpInterface] = Field(
        None, description='The associated PtpInterface object.'
    )
    typename__: Optional[Literal['PtpLinkEdge']] = Field(
        'PtpLinkEdge', alias='__typename'
    )


class PtpPath(BaseModel):
    """
    Computed path from source to destination PTP clock device.
    """

    complete: Boolean = Field(
        ...,
        description='True if path is complete - the last element in the path represents GM clock, False otherwise.',
    )
    nodes: Optional[List[ID]] = Field(
        None,
        description='Ordered list of node identifiers that compose path from source clock to destination clock.',
    )
    typename__: Optional[Literal['PtpPath']] = Field('PtpPath', alias='__typename')


class RefreshCoordinatesResponse(BaseModel):
    """
    Response containing a list of nodes with refreshed coordinates.
    """

    nodes: List[NodeCoordinates] = Field(
        ..., description='List of refreshed nodes with their new coordinates.'
    )
    typename__: Optional[Literal['RefreshCoordinatesResponse']] = Field(
        'RefreshCoordinatesResponse', alias='__typename'
    )


class RoutingPath(BaseModel):
    """
    Computed routing path from source to destination device.
    """

    nodes: List[NodeInfo] = Field(
        ...,
        description='Ordered list of nodes that compose path from source to destination device.',
    )
    weight: Int = Field(..., description='Total weight of the path.')
    typename__: Optional[Literal['RoutingPath']] = Field(
        'RoutingPath', alias='__typename'
    )


class SyncResponse(BaseModel):
    """
    Response from the sync query that contains information about synced devices from the network to topology.
    """

    devicesMissingInInventory: Optional[List[Optional[String]]] = Field(
        None,
        description='List of devices that are installed in UniConfig but are missing their metadata in DeviceMetadata collection in the\ndatabase.',
    )
    devicesMissingInUniconfig: Optional[List[Optional[String]]] = Field(
        None, description='List of devices that are not installed in UniConfig.'
    )
    labels: List[String] = Field(
        ...,
        description='List of string labels that are used for grouping of synced devices.\nList content should be the same as the list of labels in the input of the sync query.',
    )
    loadedDevices: JSON = Field(
        ...,
        description='Dictionary of devices and neighbors that are successfully synced from network to target topology.\nJSON format:\n{\n  "R1": [\n    {\n      "from_interface": "GigabitEthernet0/0/0/0",\n      "to_interface": "GigabitEthernet0/0/0/0",\n      "to_device": "R7"\n    },\n    {\n      "from_interface": "GigabitEthernet0/0/0/1",\n      "to_interface": "GigabitEthernet0/0/0/1",\n      "to_device": "R2"\n    }\n  ],\n  "R2": [\n    {\n      "from_interface": "GigabitEthernet0/0/0/0",\n      "to_interface": "GigabitEthernet0/0/0/0",\n      "to_device": "R3"\n    }\n  ]\n}',
    )
    typename__: Optional[Literal['SyncResponse']] = Field(
        'SyncResponse', alias='__typename'
    )


class SynceDevice(Node):
    """
    Representation of the device in the synce topology.
    """

    coordinates: Coordinates = Field(
        ..., description='Coordinates of the device node on the graph.'
    )
    details: SynceDeviceDetails = Field(..., description='Details of the device.')
    id: ID = Field(..., description='Unique identifier of the object.')
    labels: Optional[List[String]] = Field(
        None,
        description='List of strings that can be used for grouping of synced devices.',
    )
    name: String = Field(..., description='Human readable name of the device.')
    status: NodeStatus = Field(
        ..., description='Status of the device from the view of the synced topology.'
    )
    synceInterfaces: SynceInterfaceConnection = Field(
        ..., description='List of ports that are present on the device.'
    )
    typename__: Optional[Literal['SynceDevice']] = Field(
        'SynceDevice', alias='__typename'
    ) # type: ignore


class SynceDeviceConnection(BaseModel):
    """
    Grouped list of SynceDevice objects and pagination metadata.
    """

    edges: Optional[List[Optional[SynceDeviceEdge]]] = Field(
        None, description='List of SynceDevice objects.'
    )
    pageInfo: PageInfo = Field(..., description='Pagination metadata.')
    typename__: Optional[Literal['SynceDeviceConnection']] = Field(
        'SynceDeviceConnection', alias='__typename'
    )


class SynceDeviceDetails(BaseModel):
    """
    Details specific to SyncE (Synchronous Ethernet).
    """

    selectedForUse: Optional[String] = Field(
        None,
        description='Identifier of the reference (for example, source interface) that is used to synchronize the clock.',
    )
    typename__: Optional[Literal['SynceDeviceDetails']] = Field(
        'SynceDeviceDetails', alias='__typename'
    )


class SynceDeviceEdge(BaseModel):
    """
    Grouped SynceDevice object and associated cursor used by pagination.
    """

    cursor: String = Field(..., description='Pagination cursor for this edge.')
    node: Optional[SynceDevice] = Field(
        None, description='The associated SynceDevice object.'
    )
    typename__: Optional[Literal['SynceDeviceEdge']] = Field(
        'SynceDeviceEdge', alias='__typename'
    )


class SynceInterface(Node):
    """
    Port attached to the SyncE device.
    """

    details: Optional[SynceInterfaceDetails] = Field(
        None, description='Interface details specific to SyncE operation.'
    )
    id: ID = Field(..., description='Unique identifier of the object.')
    name: String = Field(..., description='Human readable name of the network port.')
    status: NodeStatus = Field(
        ...,
        description="Status of the interface from the view of the synced topology ('ok' or 'unknown').",
    )
    synceDevice: Optional[SynceDevice] = Field(
        None, description='Device that owns this interface.'
    )
    synceLinks: Optional[SynceLinkConnection] = Field(
        None, description='Link to connected remote synce device.'
    )
    typename__: Optional[Literal['SynceInterface']] = Field(
        'SynceInterface', alias='__typename'
    ) # type: ignore


class SynceInterfaceConnection(BaseModel):
    """
    Grouped list of SynceInterface objects and pagination metadata.
    """

    edges: Optional[List[Optional[SynceInterfaceEdge]]] = Field(
        None, description='List of SynceInterface objects.'
    )
    pageInfo: PageInfo = Field(..., description='Pagination metadata.')
    typename__: Optional[Literal['SynceInterfaceConnection']] = Field(
        'SynceInterfaceConnection', alias='__typename'
    )


class SynceInterfaceDetails(BaseModel):
    """
    Details specific to SyncE (Synchronous Ethernet).
    """

    notQualifiedDueTo: Optional[String] = Field(
        None,
        description="Information about why the interface is not qualified for SyncE synchronization\n(set to 'unknown' if the interface is qualified).",
    )
    notSelectedDueTo: Optional[String] = Field(
        None,
        description="Information about why the interface is not selected for SyncE synchronization\n(set to 'unknown' if the interface is selected).",
    )
    qualifiedForUse: Optional[String] = Field(
        None,
        description='Statement of whether the interface is qualified for SyncE synchronization.',
    )
    rxQualityLevel: Optional[String] = Field(
        None,
        description="Quality of the received SyncE signal (for example, 'DNU' or 'PRC').",
    )
    synceEnabled: Optional[Boolean] = Field(
        None, description='Configured SyncE on the port.'
    )
    typename__: Optional[Literal['SynceInterfaceDetails']] = Field(
        'SynceInterfaceDetails', alias='__typename'
    )


class SynceInterfaceEdge(BaseModel):
    """
    Grouped SynceInterface object and associated cursor used by pagination.
    """

    cursor: String = Field(..., description='Pagination cursor for this edge.')
    node: Optional[SynceInterface] = Field(
        None, description='The associated SynceInterface object.'
    )
    typename__: Optional[Literal['SynceInterfaceEdge']] = Field(
        'SynceInterfaceEdge', alias='__typename'
    )


class SynceLinkConnection(BaseModel):
    """
    Grouped list of SynceLinks objects and pagination metadata.
    """

    edges: Optional[List[Optional[SynceLinkEdge]]] = Field(
        None, description='List of SynceInterface objects.'
    )
    pageInfo: PageInfo = Field(..., description='Pagination metadata.')
    typename__: Optional[Literal['SynceLinkConnection']] = Field(
        'SynceLinkConnection', alias='__typename'
    )


class SynceLinkEdge(BaseModel):
    """
    Grouped SynceLink object and associated cursor used by pagination.
    """

    cursor: String = Field(..., description='Pagination cursor for this edge.')
    link: Optional[ID] = Field(
        None,
        description='Identifier of the link that connects this interface to the interface on the remote device',
    )
    node: Optional[SynceInterface] = Field(
        None, description='The associated SynceInterface object.'
    )
    typename__: Optional[Literal['SynceLinkEdge']] = Field(
        'SynceLinkEdge', alias='__typename'
    )


class SyncePath(BaseModel):
    """
    Computed path from source to destination SYNCE device.
    """

    complete: Boolean = Field(
        ...,
        description='True if path is complete - the last element in the path represents GM, False otherwise.',
    )
    nodes: Optional[List[ID]] = Field(
        None,
        description='Ordered list of node identifiers that compose path from source device to destination device.',
    )
    typename__: Optional[Literal['SyncePath']] = Field('SyncePath', alias='__typename')


class TopologyDevice(BaseModel):
    """
    Topology and device identifier of a device.
    """

    deviceId: ID = Field(..., description='Topology-specific device identifier.')
    topologyId: TopologyType = Field(
        ..., description='Identifier of the topology in which device is present.'
    )
    typename__: Optional[Literal['TopologyDevice']] = Field(
        'TopologyDevice', alias='__typename'
    )


class TopologyOverlayDevice(BaseModel):
    id: ID = Field(..., description='Unique identifier of the object.')
    name: String = Field(..., description='Device name.')
    secondTopologyId: Optional[ID] = Field(
        None, description='Document device ID from the second topology (can be null).'
    )
    topologyOverlayInterfaces: TopologyOverlayInterfaceConnection = Field(
        ..., description='List of ports that are present on the device.'
    )
    typename__: Optional[Literal['TopologyOverlayDevice']] = Field(
        'TopologyOverlayDevice', alias='__typename'
    )


class TopologyOverlayDeviceConnection(BaseModel):
    """
    Grouped list of TopologyOverlayDevice objects and pagination metadata.
    """

    edges: Optional[List[Optional[TopologyOverlayDeviceEdge]]] = Field(
        None, description='List of TopologyOverlayDeviceEdge objects.'
    )
    pageInfo: PageInfo = Field(..., description='Pagination metadata.')
    typename__: Optional[Literal['TopologyOverlayDeviceConnection']] = Field(
        'TopologyOverlayDeviceConnection', alias='__typename'
    )


class TopologyOverlayDeviceEdge(BaseModel):
    """
    Grouped TopologyOverlayDeviceEdge object and associated cursor used by pagination.
    """

    cursor: String = Field(..., description='Pagination cursor for this edge.')
    node: Optional[TopologyOverlayDevice] = Field(
        None, description='The associated TopologyOverlayDevice object.'
    )
    typename__: Optional[Literal['TopologyOverlayDeviceEdge']] = Field(
        'TopologyOverlayDeviceEdge', alias='__typename'
    )


class TopologyOverlayInterface(BaseModel):
    id: ID = Field(..., description='Document interface ID from the first topology')
    name: String = Field(..., description='Interface name.')
    secondTopologyId: Optional[ID] = Field(
        None, description='Document device ID from the second topology (can be null).'
    )
    topologyOverlayDevice: Optional[TopologyOverlayDevice] = Field(
        None, description='Topology overlay device that owns this interface.'
    )
    topologyOverlayLinks: Optional[TopologyOverlayLinkConnection] = Field(
        None, description='Topology overlay neighbor interface'
    )
    typename__: Optional[Literal['TopologyOverlayInterface']] = Field(
        'TopologyOverlayInterface', alias='__typename'
    )


class TopologyOverlayInterfaceConnection(BaseModel):
    """
    Grouped list of TopologyOverlayInterface objects and pagination metadata.
    """

    edges: Optional[List[Optional[TopologyOverlayInterfaceEdge]]] = Field(
        None, description='List of TopologyOverlayInterface objects.'
    )
    pageInfo: PageInfo = Field(..., description='Pagination metadata.')
    typename__: Optional[Literal['TopologyOverlayInterfaceConnection']] = Field(
        'TopologyOverlayInterfaceConnection', alias='__typename'
    )


class TopologyOverlayInterfaceEdge(BaseModel):
    """
    Grouped TopologyOverlayInterface object and associated cursor used by pagination.
    """

    cursor: String = Field(..., description='Pagination cursor for this edge.')
    node: Optional[TopologyOverlayInterface] = Field(
        None, description='The associated TopologyOverlayInterface object.'
    )
    typename__: Optional[Literal['TopologyOverlayInterfaceEdge']] = Field(
        'TopologyOverlayInterfaceEdge', alias='__typename'
    )


class TopologyOverlayLinkConnection(BaseModel):
    """
    Grouped list of TopologyOverlayLinks objects and pagination metadata.
    """

    edges: Optional[List[Optional[TopologyOverlayLinkEdge]]] = Field(
        None, description='List of TopologyOverlayInterface objects.'
    )
    pageInfo: PageInfo = Field(..., description='Pagination metadata.')
    typename__: Optional[Literal['TopologyOverlayLinkConnection']] = Field(
        'TopologyOverlayLinkConnection', alias='__typename'
    )


class TopologyOverlayLinkEdge(BaseModel):
    cursor: String = Field(..., description='Pagination cursor for this edge.')
    link: Optional[TopologyOverlayLinkIds] = Field(
        None,
        description='Identifier of the link that connects this interface to the interface on the remote device',
    )
    node: Optional[TopologyOverlayInterface] = Field(
        None, description='The associated TopologyOverlayInterface object.'
    )
    typename__: Optional[Literal['TopologyOverlayLinkEdge']] = Field(
        'TopologyOverlayLinkEdge', alias='__typename'
    )


class TopologyOverlayLinkIds(BaseModel):
    firstTopologyLinkId: ID = Field(
        ...,
        description='Identifier of the link that connects this interface to the interface on the remote device on the first topology.',
    )
    secondTopologyLinkId: Optional[ID] = Field(
        None,
        description='Identifier of the link that connects this interface to the interface on the remote device on the second topology.',
    )
    typename__: Optional[Literal['TopologyOverlayLinkIds']] = Field(
        'TopologyOverlayLinkIds', alias='__typename'
    )


class TopologyResponse(BaseModel):
    """
    Response from the topologyDiff query that contains diff between two databases.
    """

    diffData: Optional[JSON] = Field(
        None,
        description='Created diff between two databases. Format of the output JSON (\'data\' represents database document):\n{\n    "added": {"PhyDevice": [{data}], "PhyInterface": [], ...},\n    "deleted": {"PhyDevice": [{data}], "PhyInterface": [], ...},\n    "changed": {"PhyDevice": [{"new": {data}, "old"}: {data}], "PhyInterface": [{"new": {data}, "old": {data}], ...}\n}',
    )
    typename__: Optional[Literal['TopologyResponse']] = Field(
        'TopologyResponse', alias='__typename'
    )


class CoordinatesInput(BaseModel):
    """
    Input of the updateCoordinates mutation that contains information about updated coordinates of a node.
    """

    nodeName: String = Field(..., description='Name of the node in the topology.')
    nodeType: CoordinatesNodeType = Field(
        ..., description='Type of the node in the topology.'
    )
    protocolType: Optional[BgpLsProtocolType] = Field(
        None,
        description='Type of protocol (In case of network devices, necessary in case of NETWORK nodeType)',
    )
    x: Float = Field(
        ..., description='Updated horizontal coordinate of the node on the graph.'
    )
    y: Float = Field(
        ..., description='Updated vertical coordinate of the node on the graph.'
    )
    typename__: Optional[Literal['CoordinatesInput']] = Field(
        'CoordinatesInput', alias='__typename'
    )


class DeviceMetadataFilter(BaseModel):
    """
    Filter for Metadata device type based on device name, or other attributes.
    """

    deviceName: Optional[String] = Field(None, description='Regex of device name.')
    polygon: Optional[List[List[List[Float]]]] = Field(
        None,
        description='A GeoJSON Polygon shape used for filtering devices based on their location in this area.\n\nThe GeoJSON Polygon consists of a series of closed LineString objects (ring-like).\nThese Linear Ring objects consist of four or more coordinate pairs with the first and last coordinate\npair being equal. Coordinate pairs of a Polygon are an array of linear ring coordinate arrays.\nThe first element in the array represents the exterior ring.\nAny subsequent elements represent interior rings (holes within the surface).\n\nThe orientation of the first linear ring is crucial: the right-hand-rule is applied, so that the area to the left\nof the path of the linear ring (when walking on the surface of the Earth) is considered to be the interior\nof the polygon. All other linear rings must be contained within this interior.\n\nExample with a hole:\n[\n    [\n        [100.0, 0.0],\n        [101.0, 0.0],\n        [101.0, 1.0],\n        [100.0, 1.0],\n        [100.0, 0.0]\n    ],\n    [\n        [100.8, 0.8],\n        [100.8, 0.2],\n        [100.2, 0.2],\n        [100.2, 0.8],\n        [100.8, 0.8]\n    ]\n]',
    )
    topologyType: Optional[TopologyType] = Field(
        None, description='Topology in which device must be present.'
    )
    typename__: Optional[Literal['DeviceMetadataFilter']] = Field(
        'DeviceMetadataFilter', alias='__typename'
    )


class MplsDeviceFilter(BaseModel):
    """
    Filter for MplsDevice type based on device label and device name.
    """

    label: Optional[String] = Field(None, description='Device label.')
    name: Optional[String] = Field(None, description='Regex of device name.')
    typename__: Optional[Literal['MplsDeviceFilter']] = Field(
        'MplsDeviceFilter', alias='__typename'
    )


class MplsInterfaceFilter(BaseModel):
    """
    Filter for MplsInterface type based on the current interface status and name of the device.
    """

    name: Optional[String] = Field(None, description='Regex of interface name.')
    status: Optional[NodeStatus] = Field(
        None,
        description='Status of the interface from the view of the synced topology.',
    )
    typename__: Optional[Literal['MplsInterfaceFilter']] = Field(
        'MplsInterfaceFilter', alias='__typename'
    )


class NetDeviceFilter(BaseModel):
    """
    Filter for NetDevice type based on router identifier and area identifier.
    """

    ospfAreaId: Optional[String] = Field(
        None,
        description='OSPF area identifier formatted as IPv4 address (for example, 0.0.0.0 represents area 0).',
    )
    routerId: Optional[String] = Field(
        None,
        description='Regex of router identifier of the routing entity (usually IPv4 address).',
    )
    typename__: Optional[Literal['NetDeviceFilter']] = Field(
        'NetDeviceFilter', alias='__typename'
    )


class NetInterfaceFilter(BaseModel):
    """
    Filter for NetInterface type based on the configured IP address.
    """

    ipAddress: Optional[String] = Field(
        None, description='Regex of IP address configured on the interface.'
    )
    typename__: Optional[Literal['NetInterfaceFilter']] = Field(
        'NetInterfaceFilter', alias='__typename'
    )


class NetNetworkFilter(BaseModel):
    """
    Filter for NetNetwork type based on the subnet and route type.
    """

    ospfRouteType: Optional[Int] = Field(
        None, description='Type of the OSPF network (LSA type).'
    )
    subnet: Optional[String] = Field(
        None,
        description='Regex of network address including prefix length (e.g. 10.0.0.0/24)',
    )
    typename__: Optional[Literal['NetNetworkFilter']] = Field(
        'NetNetworkFilter', alias='__typename'
    )


class PhyDeviceFilter(BaseModel):
    """
    Filter for PhyDevice type based on device label and device name.
    """

    label: Optional[String] = Field(None, description='Device label.')
    name: Optional[String] = Field(None, description='Regex of device name.')
    typename__: Optional[Literal['PhyDeviceFilter']] = Field(
        'PhyDeviceFilter', alias='__typename'
    )


class PhyInterfaceFilter(BaseModel):
    """
    Filter for PhyInterface type based on the current interface status and name of the device.
    """

    name: Optional[String] = Field(None, description='Regex of interface name.')
    status: Optional[String] = Field(
        None,
        description='Status of the interface from the view of the synced topology.',
    )
    typename__: Optional[Literal['PhyInterfaceFilter']] = Field(
        'PhyInterfaceFilter', alias='__typename'
    )


class PtpDeviceFilter(BaseModel):
    """
    Filter for PtpDevice type based on device label and device name.
    """

    clockAccuracy: Optional[String] = Field(
        None, description='Regex: clock accuracy to primary reference.'
    )
    clockClass: Optional[Int] = Field(
        None, description='Measure of clock traceability.'
    )
    clockId: Optional[String] = Field(
        None, description='Regex: Unique identifier of the clock.'
    )
    clockType: Optional[String] = Field(
        None, description='Regex: Type of clock (e.g., ordinary, master).'
    )
    clockVariance: Optional[String] = Field(
        None, description='Regex: measure of clock precision.'
    )
    domain: Optional[Int] = Field(None, description='Domain of the PTP network.')
    label: Optional[String] = Field(None, description='Device label.')
    name: Optional[String] = Field(None, description='Regex of device name.')
    ptpProfile: Optional[String] = Field(
        None, description='PTP profile used (e.g., ITU-T G.8275.1).'
    )
    timeRecoveryStatus: Optional[String] = Field(
        None,
        description='Regex: indicates the current state of the time recovery process.',
    )
    typename__: Optional[Literal['PtpDeviceFilter']] = Field(
        'PtpDeviceFilter', alias='__typename'
    )


class PtpInterfaceFilter(BaseModel):
    """
    Filter for PtpInterface type based on the current interface status and name of the device.
    """

    adminOperStatus: Optional[String] = Field(
        None,
        description="Regex of administrative/operational status on the interface (e.g. 'up/up', 'up/down').",
    )
    name: Optional[String] = Field(None, description='Regex of interface name.')
    ptpStatus: Optional[String] = Field(
        None, description='Regex of the PTP process status on the interface.'
    )
    ptsfUnusable: Optional[String] = Field(
        None,
        description='Regex of unusable packet timing signal received by the slave.',
    )
    status: Optional[NodeStatus] = Field(
        None,
        description='Status of the interface from the view of the synced topology.',
    )
    typename__: Optional[Literal['PtpInterfaceFilter']] = Field(
        'PtpInterfaceFilter', alias='__typename'
    )


class SynceDeviceFilter(BaseModel):
    """
    Filter for SynceDevice type based on device label and device name.
    """

    label: Optional[String] = Field(None, description='Device label.')
    name: Optional[String] = Field(None, description='Regex of device name.')
    selectedForUse: Optional[String] = Field(
        None,
        description='Regex: identifier of the reference (for example, source interface) that is used to synchronize the clock.',
    )
    typename__: Optional[Literal['SynceDeviceFilter']] = Field(
        'SynceDeviceFilter', alias='__typename'
    )


class SynceInterfaceFilter(BaseModel):
    """
    Filter for SynceInterface type based on the current interface status and name of the device.
    """

    name: Optional[String] = Field(None, description='Regex of interface name.')
    notQualifiedDueTo: Optional[String] = Field(
        None,
        description='Regex: Information about why the interface is not qualified for SyncE synchronization.',
    )
    notSelectedDueTo: Optional[String] = Field(
        None,
        description='Regex: Information about why the interface is not selected for SyncE synchronization.',
    )
    qualifiedForUse: Optional[String] = Field(
        None,
        description='Regex: Statement of whether the interface is qualified for SyncE synchronization.',
    )
    rxQualityLevel: Optional[String] = Field(
        None,
        description="Regex: Quality of the received SyncE signal (for example, 'DNU' or 'PRC').",
    )
    status: Optional[NodeStatus] = Field(
        None,
        description='Status of the interface from the view of the synced topology.',
    )
    synceEnabled: Optional[Boolean] = Field(
        None, description='Configured SyncE on the port.'
    )
    typename__: Optional[Literal['SynceInterfaceFilter']] = Field(
        'SynceInterfaceFilter', alias='__typename'
    )


class TopologyOverlayDeviceFilter(BaseModel):
    """
    Filter for TopologyOverlayDevice type based on device name.
    """

    name: Optional[String] = Field(None, description='Regex of device name.')
    typename__: Optional[Literal['TopologyOverlayDeviceFilter']] = Field(
        'TopologyOverlayDeviceFilter', alias='__typename'
    )


class TopologyOverlayInterfaceFilter(BaseModel):
    """
    Filter for TopologyOverlayInterface type based on the name of the device.
    """

    name: Optional[String] = Field(None, description='Regex of interface name.')
    typename__: Optional[Literal['TopologyOverlayInterfaceFilter']] = Field(
        'TopologyOverlayInterfaceFilter', alias='__typename'
    )
